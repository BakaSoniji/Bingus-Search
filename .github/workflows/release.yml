name: Release - Build & Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  # Release configuration
  ENABLE_RELEASES: ${{ vars.ENABLE_RELEASES || 'true' }}
  ENABLE_HELM_PUBLISHING: ${{ vars.ENABLE_HELM_PUBLISHING || 'true' }}
  CUSTOM_REGISTRY: ${{ vars.CUSTOM_REGISTRY || '' }}  # Optional custom registry override

jobs:
  validate-config:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Make scripts executable
        run: |
          chmod +x helm/validate-config.sh
          chmod +x helm/check-config-drift.sh
          chmod +x helm/copy-configs.sh

      - name: Copy configs into chart
        run: |
          cd helm
          ./copy-configs.sh

      - name: Validate configuration sync
        run: |
          cd helm
          echo "üîç Validating Helm configuration sync..."

          # Check for schema drift
          if ! ./check-config-drift.sh; then
            echo ""
            echo "‚ùå Configuration schema drift detected!"
            echo ""
            echo "üîß To fix this issue:"
            echo "   1. Run: cd helm && ./check-config-drift.sh"
            echo "   2. Update helm/templates/api/configmap.yaml with missing fields"
            echo "   3. Test: ./validate-config.sh"
            echo "   4. Commit and push changes"
            echo ""
            exit 1
          fi

          # Validate templates render
          if ! ./validate-config.sh; then
            echo ""
            echo "‚ùå Helm template validation failed!"
            echo ""
            echo "üîß To debug:"
            echo "   1. Run: cd helm && ./validate-config.sh"
            echo "   2. Check template syntax and JSON validity"
            echo "   3. Test with: helm template . --values values.yaml"
            echo ""
            exit 1
          fi

          echo "‚úÖ Configuration validation passed!"

  validate-release:
    runs-on: ubuntu-latest
    needs: [validate-config]
    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine CalVer version
        id: version
        run: |
          # CalVer: vYYYY.MM.P (increment P within month)
          YEAR=$(date +%Y)
          MONTH=$(date +%m)
          PREFIX="v${YEAR}.${MONTH}."

          # Find latest tag with this year.month prefix
          LAST=$(git tag --list "${PREFIX}*" | sort -V | tail -n1)
          if [[ -z "$LAST" ]]; then
            PATCH=0
          else
            PATCH=${LAST##${PREFIX}}
            PATCH=$((PATCH+1))
          fi

          VERSION="${PREFIX}${PATCH}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Release version: $VERSION"

  build-release-images-amd64:
    runs-on: ubuntu-latest
    needs: validate-release

    strategy:
      matrix:
        service: [encoder, api, bot]

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Normalize repository name
        id: repo
        run: |
          echo "name=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/${{ matrix.service }}
          tags: |
            type=raw,value=${{ needs.validate-release.outputs.version }}-amd64
            type=raw,value=latest-amd64

      - name: Build and push Docker image (AMD64)
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service == 'encoder' && 'bingus-python-encoder' || '.' }}
          file: ${{ matrix.service == 'encoder' && 'bingus-python-encoder/Dockerfile' || (matrix.service == 'api' && 'api.Dockerfile' || 'bot.Dockerfile') }}
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha,scope=amd64-${{ matrix.service }}
            type=registry,ref=${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/${{ matrix.service }}:buildcache-amd64
          cache-to: |
            type=gha,mode=max,scope=amd64-${{ matrix.service }}
            type=registry,ref=${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/${{ matrix.service }}:buildcache-amd64,mode=max

  build-release-images-arm64:
    runs-on: ubuntu-24.04-arm
    needs: validate-release

    strategy:
      matrix:
        service: [encoder, api, bot]

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Normalize repository name
        id: repo
        run: |
          echo "name=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/${{ matrix.service }}
          tags: |
            type=raw,value=${{ needs.validate-release.outputs.version }}-arm64
            type=raw,value=latest-arm64

      - name: Build and push Docker image (ARM64)
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service == 'encoder' && 'bingus-python-encoder' || '.' }}
          file: ${{ matrix.service == 'encoder' && 'bingus-python-encoder/Dockerfile' || (matrix.service == 'api' && 'api.Dockerfile' || 'bot.Dockerfile') }}
          platforms: linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha,scope=arm64-${{ matrix.service }}
            type=registry,ref=${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/${{ matrix.service }}:buildcache-arm64
          cache-to: |
            type=gha,mode=max,scope=arm64-${{ matrix.service }}
            type=registry,ref=${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/${{ matrix.service }}:buildcache-arm64,mode=max

  create-release-manifest:
    runs-on: ubuntu-latest
    needs: [validate-release, build-release-images-amd64, build-release-images-arm64]

    strategy:
      matrix:
        service: [encoder, api, bot]

    steps:
      - uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Normalize repository name
        id: repo
        run: |
          echo "name=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Create and push release manifest
        run: |
          REPO_LOWER="${{ steps.repo.outputs.name }}"
          SERVICE="${{ matrix.service }}"
          VERSION="${{ needs.validate-release.outputs.version }}"

          echo "üîó Creating release manifest for: $SERVICE"

          # Create versioned manifest
          docker buildx imagetools create \
            --tag "${{ env.REGISTRY }}/${REPO_LOWER}/${SERVICE}:${VERSION}" \
            "${{ env.REGISTRY }}/${REPO_LOWER}/${SERVICE}:${VERSION}-amd64" \
            "${{ env.REGISTRY }}/${REPO_LOWER}/${SERVICE}:${VERSION}-arm64"

          # Create latest manifest
          docker buildx imagetools create \
            --tag "${{ env.REGISTRY }}/${REPO_LOWER}/${SERVICE}:latest" \
            "${{ env.REGISTRY }}/${REPO_LOWER}/${SERVICE}:latest-amd64" \
            "${{ env.REGISTRY }}/${REPO_LOWER}/${SERVICE}:latest-arm64"

          echo "‚úÖ Multi-arch manifests created for $SERVICE"

      # Cosign removed for simplicity (low traffic project)



  package-helm-chart:
    runs-on: ubuntu-latest
    needs: validate-release

    steps:
      - uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.0'

      - name: Copy configs into chart
        run: |
          cd helm
          chmod +x copy-configs.sh
          ./copy-configs.sh
          echo "‚úÖ Configs copied into chart"

      - name: Update Helm chart version
        run: |
          VERSION="${{ needs.validate-release.outputs.version }}"
          # Remove 'v' prefix for Helm chart version
          CHART_VERSION="${VERSION#v}"

          # Update Chart.yaml
          sed -i "s/^version: .*/version: $CHART_VERSION/" helm/Chart.yaml
          sed -i "s/^appVersion: .*/appVersion: \"$VERSION\"/" helm/Chart.yaml

          # Update values.yaml with new image tags
          sed -i "s/tag: latest/tag: $VERSION/g" helm/values.yaml

          echo "üì¶ Updated Helm chart to version $CHART_VERSION"

      - name: Package Helm chart
        run: |
          # Remove development files that aren't needed in the packaged chart
          cd helm
          rm -f CONFIG-SYNC.md README.md
          rm -f copy-configs.sh check-config-drift.sh validate-config.sh
          cd ..

          helm package helm/ --destination ./charts/

          # Create index for Cloudflare R2 Helm repository
          helm repo index ./charts/ --url https://charts.bakas.io

      - name: Upload to Cloudflare R2 Helm Repository
        run: |
          # Smart credential detection - use dedicated charts credentials or fall back to frontend credentials
          if [[ -n "${{ secrets.CLOUDFLARE_R2_CHARTS_ACCESS_KEY_ID }}" ]]; then
            echo "üìä Using dedicated charts R2 credentials"
            ACCESS_KEY_ID="${{ secrets.CLOUDFLARE_R2_CHARTS_ACCESS_KEY_ID }}"
            SECRET_KEY="${{ secrets.CLOUDFLARE_R2_CHARTS_SECRET_KEY }}"
            BUCKET_NAME="${{ secrets.CLOUDFLARE_R2_CHARTS_BUCKET_NAME }}"
          elif [[ -n "${{ secrets.CLOUDFLARE_R2_ACCESS_KEY_ID }}" ]]; then
            echo "üìä Reusing frontend R2 credentials for charts"
            ACCESS_KEY_ID="${{ secrets.CLOUDFLARE_R2_ACCESS_KEY_ID }}"
            SECRET_KEY="${{ secrets.CLOUDFLARE_R2_SECRET_ACCESS_KEY }}"
            BUCKET_NAME="${{ secrets.CLOUDFLARE_R2_CHARTS_BUCKET_NAME }}"
          else
            echo "‚ùå No R2 credentials found - set either CLOUDFLARE_R2_CHARTS_* or CLOUDFLARE_R2_* secrets"
            exit 1
          fi

          # Validate required configuration
          if [[ -z "$BUCKET_NAME" ]]; then
            echo "‚ùå CLOUDFLARE_R2_CHARTS_BUCKET_NAME is required"
            exit 1
          fi

          # Configure AWS CLI for Cloudflare R2
          aws configure set aws_access_key_id "$ACCESS_KEY_ID"
          aws configure set aws_secret_access_key "$SECRET_KEY"
          aws configure set default.region auto

          # Upload charts to R2 bucket
          echo "üöÄ Uploading Helm repository to Cloudflare R2..."
          aws s3 sync ./charts/ s3://"$BUCKET_NAME"/ \
            --endpoint-url https://${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.r2.cloudflarestorage.com \
            --delete \
            --cache-control "public, max-age=300"
          echo "‚úÖ Helm repository uploaded successfully"

      - name: Purge Cloudflare cache (smart detection)
        run: |
          # Smart detection - use dedicated charts API token or fall back to general cache token
          API_TOKEN=""
          ZONE_ID=""

          if [[ -n "${{ secrets.CLOUDFLARE_CHARTS_API_TOKEN }}" ]]; then
            echo "üìä Using dedicated charts API token"
            API_TOKEN="${{ secrets.CLOUDFLARE_CHARTS_API_TOKEN }}"
            ZONE_ID="${{ secrets.CLOUDFLARE_CHARTS_ZONE_ID }}"
          elif [[ -n "${{ secrets.CLOUDFLARE_CACHE_API_TOKEN }}" ]]; then
            echo "üìä Reusing general cache API token for charts"
            API_TOKEN="${{ secrets.CLOUDFLARE_CACHE_API_TOKEN }}"
            ZONE_ID="${{ secrets.CLOUDFLARE_ZONE_ID }}"
          fi

          if [[ -n "$API_TOKEN" && -n "$ZONE_ID" ]]; then
            echo "üßπ Purging Cloudflare cache for charts.bakas.io"
            curl -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/purge_cache" \
              -H "Authorization: Bearer $API_TOKEN" \
              -H "Content-Type: application/json" \
              --data '{"files":["https://charts.bakas.io/index.yaml"]}' \
              --fail && echo "‚úÖ Cache purged successfully" || echo "‚ö†Ô∏è Cache purge failed (non-critical)"
          else
            echo "‚ÑπÔ∏è Skipping cache purge - no API token configured"
          fi

      - name: Upload Helm chart artifacts (backup)
        uses: actions/upload-artifact@v4
        with:
          name: helm-charts
          path: ./charts/
          retention-days: 30

  create-release:
    runs-on: ubuntu-latest
    needs: [validate-release, create-release-manifest, package-helm-chart]

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download Helm charts
        uses: actions/download-artifact@v4
        with:
          name: helm-charts
          path: ./charts/

      - name: Generate changelog
        id: changelog
        run: |
          # Generate changelog from git commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -n "$LAST_TAG" ]; then
            echo "## üöÄ What's Changed" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            git log --pretty=format:"- %s (%an)" $LAST_TAG..HEAD >> CHANGELOG.md
          else
            echo "## üöÄ Initial Release" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "- Initial release of Bingus search application" >> CHANGELOG.md
          fi

          REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')
          echo "" >> CHANGELOG.md
          echo "## üì¶ Container Images" >> CHANGELOG.md
          echo "" >> CHANGELOG.md
          echo "- \`ghcr.io/${REPO_LOWER}/encoder:${{ needs.validate-release.outputs.version }}\`" >> CHANGELOG.md
          echo "- \`ghcr.io/${REPO_LOWER}/api:${{ needs.validate-release.outputs.version }}\`" >> CHANGELOG.md
          echo "- \`ghcr.io/${REPO_LOWER}/bot:${{ needs.validate-release.outputs.version }}\`" >> CHANGELOG.md

          echo "" >> CHANGELOG.md
          echo "## üéØ Helm Chart" >> CHANGELOG.md
          echo "" >> CHANGELOG.md
          echo "Install with:" >> CHANGELOG.md
          echo "\`\`\`bash" >> CHANGELOG.md
          echo "helm repo add bingus https://charts.bakas.io" >> CHANGELOG.md
          echo "helm install bingus bingus/bingus --version ${{ needs.validate-release.outputs.version }}" >> CHANGELOG.md
          echo "\`\`\`" >> CHANGELOG.md
          echo "" >> CHANGELOG.md
          echo "Or directly:" >> CHANGELOG.md
          echo "\`\`\`bash" >> CHANGELOG.md
          echo "helm install bingus https://charts.bakas.io/bingus-${{ needs.validate-release.outputs.version }}.tgz" >> CHANGELOG.md
          echo "\`\`\`" >> CHANGELOG.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.validate-release.outputs.version }}
          name: Release ${{ needs.validate-release.outputs.version }}
          body_path: CHANGELOG.md
          files: |
            charts/*.tgz
            charts/index.yaml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  publish-helm-chart:
    runs-on: ubuntu-latest
    needs: [validate-release, create-release]

    steps:
      - uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.0'

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download Helm charts
        uses: actions/download-artifact@v4
        with:
          name: helm-charts
          path: ./charts/

      - name: Push Helm chart to OCI registry
        run: |
          CHART_FILE=$(ls charts/*.tgz)
          REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')
          helm push "$CHART_FILE" oci://${{ env.REGISTRY }}/${REPO_LOWER}/helm

  deploy-frontend-cloudflare:
    runs-on: ubuntu-latest
    needs: [validate-release, create-release]
    if: vars.ENABLE_FRONTEND_DEPLOYMENT == 'true'

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'

      - name: Install dependencies
        run: |
          cd bingus-frontend
          npm ci

      - name: Build frontend
        run: |
          cd bingus-frontend
          npm run build
        env:
          # Optional override; if unset, frontend uses code default
          VITE_API_BASE_URL: ${{ vars.FRONTEND_API_BASE_URL }}

      - name: Validate configuration
        run: |
          if [[ -z "${{ secrets.CLOUDFLARE_R2_ACCESS_KEY_ID }}" ]]; then
            echo "‚ùå CLOUDFLARE_R2_ACCESS_KEY_ID secret is required"
            exit 1
          fi
          if [[ -z "${{ secrets.CLOUDFLARE_R2_SECRET_ACCESS_KEY }}" ]]; then
            echo "‚ùå CLOUDFLARE_R2_SECRET_ACCESS_KEY secret is required"
            exit 1
          fi
          if [[ -z "${{ secrets.CLOUDFLARE_R2_BUCKET_NAME }}" ]]; then
            echo "‚ùå CLOUDFLARE_R2_BUCKET_NAME secret is required"
            exit 1
          fi
          if [[ -z "${{ secrets.CLOUDFLARE_ACCOUNT_ID }}" ]]; then
            echo "‚ùå CLOUDFLARE_ACCOUNT_ID secret is required for R2 endpoint"
            exit 1
          fi
          echo "‚úÖ Configuration validated"

      - name: Configure AWS CLI for Cloudflare R2
        run: |
          aws configure set aws_access_key_id ${{ secrets.CLOUDFLARE_R2_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.CLOUDFLARE_R2_SECRET_ACCESS_KEY }}
          aws configure set default.region auto

      - name: Deploy to Cloudflare R2
        run: |
          echo "üöÄ Deploying frontend to Cloudflare R2..."
          aws s3 sync ./bingus-frontend/dist/ s3://${{ secrets.CLOUDFLARE_R2_BUCKET_NAME }}/ \
            --endpoint-url https://${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.r2.cloudflarestorage.com \
            --delete \
            --exact-timestamps
          echo "‚úÖ Deployment completed"

      - name: Purge Cloudflare cache
        run: |
          if [[ -n "${{ secrets.CLOUDFLARE_ZONE_ID }}" && -n "${{ secrets.CLOUDFLARE_CACHE_API_TOKEN }}" ]]; then
            echo "üßπ Purging Cloudflare cache for zone: ${{ secrets.CLOUDFLARE_ZONE_ID }}"
            curl -X POST "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/purge_cache" \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_CACHE_API_TOKEN }}" \
              -H "Content-Type: application/json" \
              --data '{"purge_everything":true}' \
              --fail
            echo "‚úÖ Cache purged successfully"
          else
            echo "‚ÑπÔ∏è Skipping cache purge - CLOUDFLARE_ZONE_ID or CLOUDFLARE_CACHE_API_TOKEN not configured"
          fi

  notify-release:
    runs-on: ubuntu-latest
    needs: [validate-release, create-release, publish-helm-chart, deploy-frontend-cloudflare]
    if: always()

    steps:
      - name: Notify release completion
        run: |
          if [[ "${{ needs.create-release.result }}" == "success" && "${{ needs.publish-helm-chart.result }}" == "success" ]]; then
            echo "üéâ Release ${{ needs.validate-release.outputs.version }} completed successfully!"
            echo "üì¶ Container images published to ghcr.io"
            echo "‚éà Helm chart published to OCI registry"
            if [[ "${{ needs.deploy-frontend-cloudflare.result }}" == "success" ]]; then
              echo "üåê Frontend deployed to Cloudflare R2"
            fi
            echo "üìã GitHub release created with changelog"
          else
            echo "‚ùå Release pipeline failed"
            exit 1
          fi
